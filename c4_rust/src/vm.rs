/// virtual machine module for executing compiled C code
/// executes the intermediate code generated by the parser

use crate::parser::{OpCode, Parser};
use std::io::{self, Read, Write};

/// VM registers and state
pub struct VM {
    code: Vec<i64>,       // code segment
    data: Vec<u8>,        // data segment
    pc: usize,            // program counter
    sp: usize,            // stack pointer
    bp: usize,            // base pointer
    ax: i64,              // accumulator
    stack: Vec<i64>,      // stack
    debug: bool,          // debug flag
    cycle: usize,         // instruction cycle counter
}

impl VM {
    /// create a new VM with the given code and data segments
    pub fn new(code: Vec<i64>, data: Vec<u8>, debug: bool) -> Self {
        // Use a smaller stack - the original C4 uses way too much memory
        // This is more than enough for test programs
        let stack_size = 1024;
        
        // Create and zero-initialize the stack
        let mut stack = Vec::with_capacity(stack_size);
        stack.resize(stack_size, 0);
        
        // Initialize sp/bp to point near the top of the stack, 
        // but leave plenty of room for working with the stack
        let sp = stack_size - 20;
        let bp = stack_size - 20;
        
        VM {
            code,
            data,
            pc: 0,
            sp,
            bp,
            ax: 0,
            stack,
            debug,
            cycle: 0,
        }
    }
    
    /// run the VM until program exit
    pub fn run(&mut self) -> Result<i64, String> {
        // Calculate stack space needed for initial frame
        if self.sp < 2 {
            return Err("Insufficient stack space for initial frame".to_string());
        }
        
        // Push EXIT opcode as return address
        self.sp -= 1;
        self.stack[self.sp] = OpCode::EXIT as i64;
        
        // TODO: Set up argc and argv for main
        
        // Main execution loop
        while self.pc < self.code.len() {
            let op = self.code[self.pc] as usize;
            self.pc += 1;
            self.cycle += 1;
            
            // Safety check - prevent infinite loops
            if self.cycle > 1_000_000 {
                return Err("Execution halted: cycle limit exceeded (possible infinite recursion)".to_string());
            }
            
            if self.debug {
                self.print_debug_info(op);
            }
            
            match op as u8 {
                // load address
                op if op == OpCode::LEA as u8 => {
                    let offset = self.next_code();
                    if self.debug {
                        println!("  LEA: bp = {}, offset = {}, addr = {}", self.bp, offset, self.bp - offset as usize);
                    }
                    // In C4, local vars are accessed at negative offsets from bp
                    self.ax = (self.bp - offset as usize) as i64;
                },
                
                // load immediate
                op if op == OpCode::IMM as u8 => {
                    self.ax = self.next_code();
                },
                
                // jump
                op if op == OpCode::JMP as u8 => {
                    self.pc = self.next_code() as usize;
                },
                
                // jump to subroutine
                op if op == OpCode::JSR as u8 => {
                    let addr = self.next_code() as usize;
                    
                    // Check stack space before pushing
                    if self.sp < 1 {
                        return Err("Stack overflow in JSR".to_string());
                    }
                    
                    // Push return address to stack
                    self.sp -= 1;
                    self.stack[self.sp] = self.pc as i64;
                    
                    // Jump to subroutine
                    self.pc = addr;
                },
                
                // branch if zero
                op if op == OpCode::BZ as u8 => {
                    let addr = self.next_code() as usize;
                    if self.ax == 0 {
                        self.pc = addr;
                    }
                },
                
                // branch if not zero
                op if op == OpCode::BNZ as u8 => {
                    let addr = self.next_code() as usize;
                    if self.ax != 0 {
                        self.pc = addr;
                    }
                },
                
                // enter subroutine
                op if op == OpCode::ENT as u8 => {
                    let frame_size = self.next_code() as usize;
                    if self.debug {
                        println!("  ENT: creating stack frame with {} local variables", frame_size);
                    }
                    
                    // Ensure we have enough stack space
                    if self.sp < frame_size + 1 {
                        return Err(format!("Stack overflow in ENT: need {} slots but only {} available",
                                         frame_size + 1, self.sp));
                    }
                    
                    // Save old base pointer
                    self.sp -= 1;
                    self.stack[self.sp] = self.bp as i64;
                    
                    // Set new base pointer to current stack position
                    self.bp = self.sp;
                    
                    // Allocate space for local variables
                    if frame_size > 0 {
                        self.sp -= frame_size;
                        
                        // Initialize local variables to 0
                        for i in 0..frame_size {
                            if self.sp + i < self.stack.len() {
                                self.stack[self.sp + i] = 0;
                            }
                        }
                    }
                },
                
                // adjust stack
                op if op == OpCode::ADJ as u8 => {
                    self.sp += self.next_code() as usize;
                },
                
                // leave subroutine
                op if op == OpCode::LEV as u8 => {
                    // Before modifying stack pointers, verify all operations are in bounds
                    if self.bp >= self.stack.len() {
                        return Err(format!("Invalid base pointer in LEV: bp={}, stack len={}", 
                                          self.bp, self.stack.len()));
                    }
                    
                    // Restore stack pointer to current base pointer
                    self.sp = self.bp;
                    
                    // Get previous base pointer
                    let prev_bp = self.stack[self.sp] as usize;
                    
                    // Update base pointer
                    self.bp = prev_bp;
                    self.sp += 1;
                    
                    // Check if we can safely access the return address
                    if self.sp >= self.stack.len() {
                        // We're at the end of the stack - this must be returning to EXIT
                        // Set ax as the return value and exit
                        return Ok(self.ax);
                    }
                    
                    // Get return address
                    let ret_addr = self.stack[self.sp] as usize;
                    self.sp += 1;
                    
                    // Set program counter to return address
                    self.pc = ret_addr;
                    
                    // When returning to EXIT instruction, push return value to stack
                    if self.pc >= self.code.len() || 
                       (self.pc < self.code.len() && self.code[self.pc] as u8 == OpCode::EXIT as u8) {
                        if self.sp == 0 {
                            return Err("Stack overflow in LEV before EXIT".to_string());
                        }
                        self.sp -= 1;
                        self.stack[self.sp] = self.ax;
                    }
                },
                
                // load int (from local variable)
                op if op == OpCode::LI as u8 => {
                    let addr = self.ax as usize;
                    if self.debug {
                        println!("  LI: loading from stack addr {}", addr);
                    }
                    
                    // Check if address is valid before loading
                    if addr >= self.stack.len() {
                        return Err(format!("Invalid memory access: tried to load from address {} but stack size is {}", addr, self.stack.len()));
                    }
                    
                    self.ax = self.stack[addr];
                    if self.debug {
                        println!("  LI: loaded value {}", self.ax);
                    }
                },
                
                // load char
                op if op == OpCode::LC as u8 => {
                    let addr = self.ax as usize;
                    if self.debug {
                        println!("  LC: loading char from stack addr {}", addr);
                    }
                    
                    // Check if address is valid before loading
                    if addr >= self.stack.len() {
                        return Err(format!("Invalid memory access: tried to load char from address {} but stack size is {}", addr, self.stack.len()));
                    }
                    
                    self.ax = (self.stack[addr] & 0xFF) as i64;
                },
                
                // store int (to local variable)
                op if op == OpCode::SI as u8 => {
                    let addr = self.stack[self.sp] as usize;
                    if self.debug {
                        println!("  SI: storing {} to stack addr {}", self.ax, addr);
                    }
                    
                    // Check if address is valid before storing
                    if addr >= self.stack.len() {
                        return Err(format!("Invalid memory access: tried to store at address {} but stack size is {}", addr, self.stack.len()));
                    }
                    
                    self.stack[addr] = self.ax;
                    self.sp += 1;
                },
                
                // store char
                op if op == OpCode::SC as u8 => {
                    let addr = self.stack[self.sp] as usize;
                    if self.debug {
                        println!("  SC: storing char {} to stack addr {}", self.ax & 0xFF, addr);
                    }
                    
                    // Check if address is valid before storing
                    if addr >= self.stack.len() {
                        return Err(format!("Invalid memory access: tried to store char at address {} but stack size is {}", addr, self.stack.len()));
                    }
                    
                    let current_value = self.stack[addr];
                    self.stack[addr] = (current_value & !0xFF) | (self.ax & 0xFF); // Preserve other bits
                    self.sp += 1;
                },
                
                // push
                op if op == OpCode::PSH as u8 => {
                    if self.sp == 0 {
                        return Err("Stack overflow in PSH operation".to_string());
                    }
                    self.sp -= 1;
                    self.stack[self.sp] = self.ax;
                },
                
                // binary ops
                op if op == OpCode::OR as u8 => {
                    self.ax = self.stack[self.sp] | self.ax;
                    self.sp += 1;
                },
                op if op == OpCode::XOR as u8 => {
                    self.ax = self.stack[self.sp] ^ self.ax;
                    self.sp += 1;
                },
                op if op == OpCode::AND as u8 => {
                    self.ax = self.stack[self.sp] & self.ax;
                    self.sp += 1;
                },
                
                // comparison
                op if op == OpCode::EQ as u8 => {
                    self.ax = (self.stack[self.sp] == self.ax) as i64;
                    self.sp += 1;
                },
                op if op == OpCode::NE as u8 => {
                    self.ax = (self.stack[self.sp] != self.ax) as i64;
                    self.sp += 1;
                },
                op if op == OpCode::LT as u8 => {
                    self.ax = (self.stack[self.sp] < self.ax) as i64;
                    self.sp += 1;
                },
                op if op == OpCode::GT as u8 => {
                    self.ax = (self.stack[self.sp] > self.ax) as i64;
                    self.sp += 1;
                },
                op if op == OpCode::LE as u8 => {
                    self.ax = (self.stack[self.sp] <= self.ax) as i64;
                    self.sp += 1;
                },
                op if op == OpCode::GE as u8 => {
                    self.ax = (self.stack[self.sp] >= self.ax) as i64;
                    self.sp += 1;
                },
                
                // bit shifting
                op if op == OpCode::SHL as u8 => {
                    self.ax = self.stack[self.sp] << self.ax;
                    self.sp += 1;
                },
                op if op == OpCode::SHR as u8 => {
                    self.ax = self.stack[self.sp] >> self.ax;
                    self.sp += 1;
                },
                
                // arithmetic
                op if op == OpCode::ADD as u8 => {
                    self.ax = self.stack[self.sp] + self.ax;
                    self.sp += 1;
                },
                op if op == OpCode::SUB as u8 => {
                    self.ax = self.stack[self.sp] - self.ax;
                    self.sp += 1;
                },
                op if op == OpCode::MUL as u8 => {
                    self.ax = self.stack[self.sp] * self.ax;
                    self.sp += 1;
                },
                op if op == OpCode::DIV as u8 => {
                    if self.ax == 0 {
                        return Err("division by zero".to_string());
                    }
                    self.ax = self.stack[self.sp] / self.ax;
                    self.sp += 1;
                },
                op if op == OpCode::MOD as u8 => {
                    if self.ax == 0 {
                        return Err("modulo by zero".to_string());
                    }
                    self.ax = self.stack[self.sp] % self.ax;
                    self.sp += 1;
                },
                
                // system calls
                op if op == OpCode::OPEN as u8 => {
                    self.ax = self.syscall_open()?;
                },
                op if op == OpCode::READ as u8 => {
                    self.ax = self.syscall_read()?;
                },
                op if op == OpCode::CLOS as u8 => {
                    self.ax = 0; // file close not supported, return success
                },
                op if op == OpCode::PRTF as u8 => {
                    self.ax = self.syscall_printf()?;
                },
                op if op == OpCode::MALC as u8 => {
                    self.ax = self.syscall_malloc()?;
                },
                op if op == OpCode::FREE as u8 => {
                    // free not supported, just remove from stack
                    self.sp += 1;
                    self.ax = 0;
                },
                op if op == OpCode::MSET as u8 => {
                    self.ax = self.syscall_memset()?;
                },
                op if op == OpCode::MCMP as u8 => {
                    self.ax = self.syscall_memcmp()?;
                },
                op if op == OpCode::EXIT as u8 => {
                    if self.debug {
                        println!("exit({}) cycle = {}", self.stack[self.sp], self.cycle);
                    }
                    return Ok(self.stack[self.sp]);
                },
                
                // unknown instruction
                _ => return Err(format!("unknown instruction: {}", op)),
            }
        }
        
        // if we reach the end of code without an EXIT instruction
        // assume it was from the main function return, and use ax as return value
        if self.debug {
            println!("program reached end, returning value {} after {} cycles", self.ax, self.cycle);
        }
        
        // we push the return value to the stack and return it
        self.sp -= 1;
        self.stack[self.sp] = self.ax;
        Ok(self.stack[self.sp])
    }
    
    /// print debug info for current instruction
    fn print_debug_info(&self, op: usize) {
        const OP_NAMES: &[&str] = &[
            "LEA ", "IMM ", "JMP ", "JSR ", "BZ  ", "BNZ ", "ENT ", "ADJ ", "LEV ", "LI  ", "LC  ", "SI  ", "SC  ", "PSH ",
            "OR  ", "XOR ", "AND ", "EQ  ", "NE  ", "LT  ", "GT  ", "LE  ", "GE  ", "SHL ", "SHR ", "ADD ", "SUB ", "MUL ", "DIV ", "MOD ",
            "OPEN", "READ", "CLOS", "PRTF", "MALC", "FREE", "MSET", "MCMP", "EXIT",
        ];
        
        if op < OP_NAMES.len() {
            print!("{}> {}", self.cycle, OP_NAMES[op]);
            // print immediate value for instructions that use it
            if op <= OpCode::ADJ as usize && self.pc < self.code.len() {
                println!(" {}", self.code[self.pc]);
            } else {
                println!();
            }
        } else {
            println!("{}> Unknown op: {}", self.cycle, op);
        }
    }
    
    /// get next code value and advance pc
    fn next_code(&mut self) -> i64 {
        let val = self.code[self.pc];
        self.pc += 1;
        val
    }
    
    /// load int from memory
    fn load_int(&self, addr: usize) -> i64 {
        if self.debug {
            println!("  Loading int from addr {}, data len: {}", addr, self.data.len());
        }
        
        // Check if address is within bounds
        if addr < self.data.len() && addr + 7 < self.data.len() {
            // load from data segment
            let mut bytes = [0u8; 8];
            for i in 0..8 {
                bytes[i] = self.data[addr + i];
            }
            
            let value = i64::from_ne_bytes(bytes);
            if self.debug {
                println!("  Loaded bytes: {:?}, int value: {}", bytes, value);
            }
            value
        } else {
            // For short data segments (like our simple test), use a single byte value
            if addr < self.data.len() {
                let value = self.data[addr] as i64;
                if self.debug {
                    println!("  Data segment too short, loaded single byte: {}", value);
                }
                value
            } else {
                // invalid memory access
                if self.debug {
                    println!("  Invalid memory access at address {}", addr);
                }
                0
            }
        }
    }
    
    /// load char from memory
    fn load_char(&self, addr: usize) -> u8 {
        if addr < self.data.len() {
            self.data[addr]
        } else {
            0
        }
    }
    
    /// store int to memory
    fn store_int(&mut self, addr: usize, val: i64) {
        if self.debug {
            println!("  Storing int value: {} at address: {}", val, addr);
        }
        
        if addr + 7 >= self.data.len() {
            // grow data segment if needed
            self.data.resize(addr + 8, 0);
        }
        
        let bytes = val.to_ne_bytes();
        for i in 0..8 {
            self.data[addr + i] = bytes[i];
        }
        
        if self.debug {
            println!("  Stored bytes: {:?}", bytes);
        }
    }
    
    /// store char to memory
    fn store_char(&mut self, addr: usize, val: u8) {
        if addr >= self.data.len() {
            // grow data segment if needed
            self.data.resize(addr + 1, 0);
        }
        
        self.data[addr] = val;
    }
    
    /// syscall: open
    fn syscall_open(&mut self) -> Result<i64, String> {
        // Not fully implemented - minimal support for tests
        self.sp += 2; // remove path and flags from stack
        Ok(0) // return fake file descriptor
    }
    
    /// syscall: read 
    fn syscall_read(&mut self) -> Result<i64, String> {
        // Not fully implemented - minimal support for tests
        self.sp += 3; // remove fd, buffer, count from stack
        Ok(0) // return read count of 0
    }
    
    /// syscall: printf
    fn syscall_printf(&mut self) -> Result<i64, String> {
        // Basic support for printf
        let args = self.next_code() as usize;
        
        println!("PRINTF DEBUG: syscall_printf called with {} arguments", args);
        
        // Check if we have enough arguments on stack
        if self.sp + args > self.stack.len() {
            return Err(format!("Not enough arguments for printf: sp={}, args={}, stack len={}", 
                              self.sp, args, self.stack.len()));
        }
        
        // Format string is the first argument (which is the last one pushed)
        let format_addr = self.stack[self.sp + args - 1] as usize;
        println!("PRINTF DEBUG: format_addr = {}", format_addr);
        
        // Read format string from data segment
        let mut format_str = String::new();
        let mut i = format_addr;
        while i < self.data.len() && self.data[i] != 0 {
            format_str.push(self.data[i] as char);
            i += 1;
        }
        
        println!("PRINTF DEBUG: format string: \"{}\"", format_str);
        println!("PRINTF DEBUG: args: {}", args - 1);  // Subtract 1 for format string
        
        // Handle format specifiers
        let mut result = String::new();
        let mut chars = format_str.chars().peekable();
        
        // Start at the second argument (index args-2)
        let mut arg_index = args - 2;
        
        while let Some(c) = chars.next() {
            if c == '%' && chars.peek().is_some() {
                match chars.next().unwrap() {
                    'd' => {
                        if arg_index < self.sp + args && arg_index >= self.sp {
                            println!("PRINTF DEBUG: handling %d, arg_index={}, value={}", 
                                    arg_index, self.stack[arg_index]);
                            result.push_str(&self.stack[arg_index].to_string());
                            if arg_index > self.sp {
                                arg_index -= 1;
                            }
                        } else {
                            result.push_str("?");
                        }
                    },
                    's' => {
                        if arg_index < self.sp + args && arg_index >= self.sp {
                            let str_addr = self.stack[arg_index] as usize;
                            println!("PRINTF DEBUG: handling %s, arg_index={}, str_addr={}", 
                                    arg_index, str_addr);
                            let mut j = str_addr;
                            while j < self.data.len() && self.data[j] != 0 {
                                result.push(self.data[j] as char);
                                j += 1;
                            }
                            if arg_index > self.sp {
                                arg_index -= 1;
                            }
                        } else {
                            result.push_str("?");
                        }
                    },
                    c => {
                        result.push('%');
                        result.push(c);
                    },
                }
            } else {
                result.push(c);
            }
        }
        
        // Print the result
        println!("PRINTF DEBUG: final result: \"{}\"", result);
        print!("{}", result);
        let _ = io::stdout().flush();
        
        // Clean up arguments from stack
        self.sp += args;
        
        // Return number of characters printed
        Ok(result.len() as i64)
    }
    
    /// syscall: malloc
    fn syscall_malloc(&mut self) -> Result<i64, String> {
        let size = self.stack[self.sp] as usize;
        self.sp += 1;
        
        // simple allocation from data segment
        let addr = self.data.len();
        self.data.resize(addr + size, 0);
        
        Ok(addr as i64)
    }
    
    /// syscall: memset
    fn syscall_memset(&mut self) -> Result<i64, String> {
        let count = self.stack[self.sp] as usize;
        let value = self.stack[self.sp + 1] as u8;
        let dest = self.stack[self.sp + 2] as usize;
        self.sp += 3;
        
        if dest + count > self.data.len() {
            self.data.resize(dest + count, 0);
        }
        
        for i in 0..count {
            self.data[dest + i] = value;
        }
        
        Ok(dest as i64)
    }
    
    /// syscall: memcmp
    fn syscall_memcmp(&mut self) -> Result<i64, String> {
        let count = self.stack[self.sp] as usize;
        let s2 = self.stack[self.sp + 1] as usize;
        let s1 = self.stack[self.sp + 2] as usize;
        self.sp += 3;
        
        if s1 + count > self.data.len() || s2 + count > self.data.len() {
            return Ok(-1); // out of bounds comparison
        }
        
        for i in 0..count {
            let a = self.data[s1 + i];
            let b = self.data[s2 + i];
            if a != b {
                return Ok((a as i64) - (b as i64));
            }
        }
        
        Ok(0) // identical
    }
}

/// entry point for the compiler - compiles and runs the source code
pub fn run(source: &str, src: bool, debug: bool) -> Result<i64, String> {
    // parse the source code
    let mut parser = Parser::new(source, src);
    parser.init()?;
    let result = parser.parse();
    
    if result.is_err() {
        return Err(result.unwrap_err());
    }
    
    let (code, data) = result.unwrap();
    
    // if only parsing was requested, return early
    if src {
        return Ok(0);
    }
    
    // create and run VM
    let mut vm = VM::new(code, data, debug);
    let result = vm.run();
    
    // print result if debug is enabled
    if let Ok(return_val) = result.as_ref() {
        if debug {
            println!("Program executed successfully, returned: {}", return_val);
        }
    }
    
    result
} 